# 事件循环

## 单线程、非阻塞 I/O、事件驱动(以 node 为例)

- 这三个其实是一回事,普通的服务端语言大多是多线程,阻塞 io,像 java(当然也有 nio),有请求就会开出一个线程单独给这个请求分配内存,后面的 session,响应都是这个线程负责,但 node 是单线程,也就是说,主线程同一时间只能做一件事,进入了一个函数,没有执行完就不会执行另一个函数,相当的专一,有的朋友就会问了,那我在函数里写文件读取不就阻塞了吗？这时候就要提另外一个特点,事件驱动,也就是事件循环,事件驱动使得让一部分操作,延迟到下次再做,比如说进入一个函数,要读取一个文件,得到文件后再进行一个操作,等程序运行到读文件这个操作时,就会让底层去读,先不等读完,先干后面的事,当文件读完时,后续操作就会被扔到任务队列,等主线程有空再做.非阻塞式 io 也就是这个道理.先干别的事不就不阻塞了吗.

**缺点**
有得必有失,单线程带来了高并发的同时也带来了缺点

##### 1.主线程堵塞后续操作全部堵塞

比如说,再某个请求处理函数中,有一个无限循环,那就完了,后续什么都干不了了,而多线程就不一样,线程之间彼此独立,一个线程堵塞了,其他也没有关系.

##### 2.callback 太多时,不易维护

作为 node 特点之一的事件驱动,实质就是把费时的事放到后面去做而不是不做,而费事的事中也有费时的事,这样一来,callback 栈就不直观,甚至会混乱,导致出问题时不容易定位

##### 3.无法利用多核,一旦进程出现异常没有捕获进程奔溃退出

线程级程序可以交由多个核处理,单线程无能为力

**补救措施**

1. 多打断点,多 debug,别写死循环
2. callback 函数写名字,async/await
3. cluster,Pm2

## 浏览器中的事件循环

![eventloop](https://img2018.cnblogs.com/blog/1101905/201912/1101905-20191218091238946-129679312.png)

1. 首先执行同步代码,这属于宏任务
2. 当执行完所有同步代码后,执行栈为空,查询是否有异步代码需要执行
3. 执行所有微任务
4. 当执行完所有微任务后,如有必要会渲染页面
5. 然后开始下一轮 Event Loop,执行宏任务中的异步代码,也就是 setTimeout 中的回调函数

**简单的说就是执行一个宏任务处理所有微任务**

## node 中的事件循环

```js
   ┌───────────────────────┐
┌  │        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │  pending callbacks    │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │ ─────┤  connections  │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

**每个阶段都维护一个任务队列,进行下一阶段的最低条件是清空本阶段任务队列的任务**

### 重点阶段说明

##### 1.timers

这个阶段执行 setTimeout(callback) 和 setInterval(callback) 预定的 callback;
**注意:setTimeout(callback,0) 在 node 中会被强制转换为 setTimeout(callback,1)**

##### 2.pending,callback

系统底层操作的回调,如 TCP 错误

##### 3.idle,prepare

闲置预备阶段,仅供内部使用,不做讨论

##### 4.poll:轮询

处理 I/O 事件的回调,适当时候,Node 将在这里堵塞

##### 5.cheak

setImmediate 的回调在此执行

##### 6.close callback

关闭的回调,close 事件的监听回调

### 重点解释

##### 1.poll 阶段

主要任务

- 计算定时器应该阻塞的时间
- 执行该阶段队列的所有回调函数(I/O 回调）
- 如果队列为空,也就是没有工作可做,这是如果有 setImmediate 设置的回调存在,就会直接结束该阶段,不会等待响应的 I/O 回调,如果没有 setImmediate 设置的回调队列,就会等待 I/O 操作

**有事就干事,没事就等等**

_举个例子_
比如有一个设置了 100ms 后执行的定时器,同时有一个 I/O 操作,交给内核,内核正在读取文件,当事件循环开始时,timers 阶段显示时间没到 100ms,跳过进入 poll 阶段,此时文件还没有读完,但因为 poll 阶段检测到也没到定时器的 100ms,所以即使进行下一轮的事件循环还是会跳过 timers 阶段,所以决定等待文件读取的操作,就是堵塞在 poll 阶段,直到 100ms,此时如果文件读取完成,就会把文件读取的回调执行完,再进入下一轮事件循环,执行 timers 的定时器,但有一个情况会有所不同,就是在 cheak 阶段的队列不为空,即有 setImmediate 设置的回调,此时的 poll 阶段就不会等待 I/O 操作,而是会直接清空该阶段的任务队列再进入 cheak 阶段,清空 cheak 阶段的任务队列.

##### 2.setImmediate 和 setTimeout

用于不同,setImmediate 意为在本轮 I/O 操作后马上执行回调,setTimeout 则是一段时间后,尽可能快的执行回调

##### 3.process.nextTick

独立维护一个队列,在每个阶段结束后,都会优先清空该队列

### node 中的事件循环和宏任务微任务

##### 宏任务:

- setTimeout
- setInterval
- setImmediate
- I/O 回调
- 同步脚本

##### 微任务:

- process.nxetTick
- promise 家族

**注意**

- process.nextTick 优先级大于 promise
- 每处理一个宏任务都会处理掉所有微任务

![node](https://img2018.cnblogs.com/blog/1101905/201912/1101905-20191218091703162-2068677203.png)
